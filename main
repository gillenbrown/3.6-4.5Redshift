#! /usr/bin/env python

import os
import sys

from redshift import cluster

def abs_path(path):
    if path.startswith("/"):
        # is an absolute path, so we don't need to do anythin
        return path
    elif path.startswith("~/"):
        # is relative to home, which is easy.
        return os.path.expanduser(path)
    elif path.startswith(".") and not path.startswith(".."):
        return os.getcwd() + path[1:]  # ignore the dot
    elif path[0].isalnum():
        return os.getcwd() + os.sep + path
    elif path.startswith(".."):
        current = os.getcwd()
        above = os.sep.join(current.split(os.sep)[0:-1])
        return above + path[2:]
    else:
        raise ValueError("Path format not recognized.")


def parse_config():
    """Parse the config file, making a dictionary of parameters

    :return: dictionary, with keys of parameter names, and values of the
    desired values for those parameters.
    """
    global params  # params needs to be available elsewhere
    params = dict()

    # the user can pass in a parameter, which will be the config file
    # location. Open that if available, and the default if not.
    if len(sys.argv) > 1:
        config_path = sys.argv[1]
        try:
            config_file = open(config_path)
        except IOError:
            print config_path + " was not found. Opening default config file."
            config_file = open("config.txt")
    else:
        config_file = open("config.txt")


    for line in config_file:
        if not line.startswith("#") and not line.isspace():
            params[line.split()[0]] = line.split()[2]
    config_file.close()

    # turn the path variables into absolute paths, if they were passed in in
    #  some other format.
    paths = ["catalog_directory", "plot_directory", "results_file"]
    for path in paths:
        params[path] = abs_path(params[path])

    return params


def start_output():
    """Start the output file, and put the header in the file.

    :return: open file object pointing to the output file.
    """
    output_file = open(params["results_file"], "w")
    header = '# {:15s}{:6s}{:6s}{:6s}'.format("name", "z", "ezu", "ezd")
    output_file.write(header)
    return output_file

def add_to_catalog(output_file, cluster):
    """

    :param cluster:
    :return:
    """
    line = '\n{:17s}{:<6f}{:<6f}{:<6f}'.format(cluster.name, cluster.z.value,
                                          cluster.z.upper_error,
                                          cluster.z.lower_error)
    output_file.write(line)


def main():
    # parse the config file
    params = parse_config()

    catalogs = os.listdir(params["catalog_directory"])
    # weed out things that aren't catalogs
    catalogs = [cat for cat in catalogs if cat.endswith(params["extension"])]

    # start the output file
    output_file = start_output()

    for cat in catalogs:
        filepath = params["catalog_directory"] + cat
        cl = cluster.Cluster(filepath)

        # do the fitting procedure
        cl.fit_z(params)

        # make the output catalog
        add_to_catalog(output_file, cl)

    output_file.close()
    pass




if __name__ == "__main__":
    main()

# TODO: actual slopes of the red sequence
# TODO: What is the format of the catalogs I will get?
# TODO: correction
# TODO: print nice header when the code runs, and some indication of how the
#  code is running.
# TODO: make a readme that explains everything about the program.
# TODO: document results file

