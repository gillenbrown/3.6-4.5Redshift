#! /usr/bin/env python

import os
import sys

from rsz_irac_code import cluster

def abs_path(path):
    """Makes and given path into an absolute path.

    Works for paths that are already aboluste, paths which start with ~/ and
    . and .. as well as paths that are just a file or folder. All relative
    paths are assumed to be relative to the current working directory.

    :param path: path to be made absolute
    :return: string with the absolute path
    """
    if path.startswith("/"):
        # is an absolute path, so we don't need to do anythin
        return path
    elif path.startswith("~/"):
        # is relative to home, which is easy.
        return os.path.expanduser(path)
    elif path.startswith(".."):
        above = (os.sep).join(os.getcwd().split(os.sep)[0:-1])
        # The 0:-1 is to get rid of the last path (our current directory),
        # which will give us the directory above
        return above + path[2:]  # get rid of ..
    elif path.startswith("."):
        return os.getcwd() + path[1:]  # get rid of .
    elif path[0].isalnum():
        return os.getcwd() + os.sep + path
    else:
        raise ValueError("Path format not recognized.")


def parse_config():
    """Parse the config file, making a dictionary of parameters

    :return: dictionary, with keys of parameter names, and values of the
    desired values for those parameters.
    """

    # the user can pass in a parameter when calling the program from the
    # command line, which will be the config file location. Open that if
    # available, and the default if not.
    if len(sys.argv) > 1:
        config_path = sys.argv[1]
        try:
            config_file = open(config_path)
        except IOError:
            print config_path + " was not found. Opening default config file."
            config_file = open("config.txt")
    else:
        config_file = open("config.txt")

    # parse the file into a parameters dictionary
    global params  # params needs to be available elsewhere
    params = dict()
    for line in config_file:
        if not line.startswith("#") and not line.isspace():
            params[line.split()[0]] = line.split()[2]
    config_file.close()

    # turn the path variables into absolute paths, if they were passed in in
    #  some other format.
    paths = ["catalog_directory", "plot_directory", "results_file"]
    for path in paths:
        params[path] = abs_path(params[path])

    return params


def start_output():
    """Start the output file, and put the header in the file.

    :return: open file object pointing to the output file.
    """
    output_file = open(params["results_file"], "w")
    header = '# {:15s}{:6s}{:6s}{:6s}'.format("name", "z", "ezu", "ezd")
    output_file.write(header)
    return output_file

def add_to_catalog(output_file, cluster):
    """

    :param cluster:
    :return:
    """
    line = '\n{:17s}{:<6f}{:<6f}{:<6f}'.format(cluster.name, cluster.z.value,
                                          cluster.z.upper_error,
                                          cluster.z.lower_error)
    output_file.write(line)


def main():
    # parse the config file
    params = parse_config()

    catalogs = os.listdir(params["catalog_directory"])
    # weed out things that aren't catalogs
    catalogs = [cat for cat in catalogs if cat.endswith(params["extension"])]

    # start the output file
    output_file = start_output()

    for cat in catalogs:
        filepath = params["catalog_directory"] + cat
        cl = cluster.Cluster(filepath)

        # do the fitting procedure
        cl.fit_z(params)

        # make the output catalog
        add_to_catalog(output_file, cl)

    output_file.close()
    pass




if __name__ == "__main__":
    main()

# TODO: find a good name for the code.
# TODO: actual slopes of the red sequence
# TODO: What is the format of the catalogs I will get?
# TODO: correction
# TODO: print nice header when the code runs, and some indication of how the
#  code is running.
# TODO: make a readme that explains everything about the program.
# TODO: document results file
# TODO: make a .txt file documenting how to run the code.