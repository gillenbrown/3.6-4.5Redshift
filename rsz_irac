#! /usr/bin/env python

# TODO: make the catalog search function recursively find all files in each
# subdirectory too.

import os
import sys

from rsz_irac_code import cluster

def abs_path(path):
    """Makes and given path into an absolute path.

    Works for paths that are already aboluste, paths which start with ~/ and
    . and .. as well as paths that are just a file or folder. All relative
    paths are assumed to be relative to the current working directory.

    :param path: path to be made absolute
    :return: string with the absolute path
    """
    if path.startswith("/"):
        # is an absolute path, so we don't need to do anythin
        return path
    elif path.startswith("~/"):
        # is relative to home, which is easy.
        return os.path.expanduser(path)
    elif path.startswith(".."):
        above = (os.sep).join(os.getcwd().split(os.sep)[0:-1])
        # The 0:-1 is to get rid of the last path (our current directory),
        # which will give us the directory above
        return above + path[2:]  # get rid of ..
    elif path.startswith("."):
        return os.getcwd() + path[1:]  # get rid of .
    elif path[0].isalnum():
        return os.getcwd() + os.sep + path
    else:
        raise ValueError("Path format not recognized.")


def parse_config():
    """Parse the config file, making a dictionary of parameters

    :return: dictionary, with keys of parameter names, and values of the
    desired values for those parameters.
    """

    # the user can pass in a parameter when calling the program from the
    # command line, which will be the config file location. Open that if
    # available, and the default if not.
    if len(sys.argv) > 1:
        config_path = sys.argv[1]
        try:
            config_file = open(config_path)
        except IOError:
            print config_path + " was not found. Opening default .param file."
            config_file = open("rsz_irac.param")
    else:
        config_file = open("rsz_irac.param")

    # parse the file into a parameters dictionary
    global params  # params needs to be available elsewhere
    params = dict()
    for line in config_file:
        if not line.startswith("#") and not line.isspace():
            params[line.split()[0]] = line.split()[2]
    config_file.close()

    # turn the path variables into absolute paths, if they were passed in in
    #  some other format.
    paths = ["catalog_directory", "plot_directory", "results_file"]
    for path in paths:
        params[path] = abs_path(params[path])

    return params


def get_catalogs(parent_directory, extension):
    """Gets all the catalogs in the parent directory (and its subdirectories)
    that end with extension.

    :param parent_directory: parent directory to search for catalogs.
    :param extension: extension of the files that will be returned
    :return: List of paths to files in parent_directory that end with
             extension.
    """
    catalogs = []
    for dirpath, dirnames, filenames in os.walk(parent_directory):
        for filename in filenames:
            if filename.endswith(extension):
                catalogs.append(os.path.join(dirpath, filename))
    return catalogs

def start_output():
    """Start the output file, and put the header in the file.

    :return: open file object pointing to the output file.
    """
    output_file = open(params["results_file"], "w")
    header = "# " + 20*"-" + 3*" " + "rsz_irac results" + 3*" " + 20*"-" + \
             "\n" + \
             "#\n" + \
             "# - name: name of the cluster\n" + \
             "# - z: best fit redshift of the cluster\n" + \
             "# - ez+: 1 sigma error on the redshift above the best fit\n" + \
             "# - ez-: 1 sigma error on the redshift below the best fit\n" + \
             "# - flag: sum of the following flags:\n" + \
             "#         1: Not much clustering. The objects marked as red" + \
             " sequence members\n" + \
             "#            weren't centrally concentrated.\n" + \
             "#         2: Possible double red sequence. There are two" + \
             " maximums in the\n" + \
             "#            likelihood of redshift.\n" + \
             "#         4: Indistinct red sequence. The red sequence isn't" + \
             " clean.\n" + \
             "#\n" + \
             "#" + 63*"-" + "\n" + "#\n"
    output_file.write(header)
    labels = '# {:15s}{:6s}{:6s}{:6s}{:6s}'.format("name", "z", "ez+",
                                                   "ez-", "flags")
    output_file.write(labels)
    return output_file

def add_to_catalog(output_file, cluster):
    """

    :param cluster:
    :return:
    """
    line = '\n{:17s}{:<6f}{:<6f}{:<6f}{:<6}'.format(cluster.name.replace(" ", "_"),
                                               cluster.z.value,
                                               cluster.z.upper_error,
                                               cluster.z.lower_error,
                                               cluster.flags)
    output_file.write(line)


def main():
    header =  "\n+" + 25*"-" + 6*" " + "rsz_irac" + 6*" " + 25*"-" + "+\n" +\
              "|" + 70*" " + "|\n" + \
              "|" + 5*" " + "Remember the clusters must be above z=0.7 for " \
                            "this to work!" + 6*" " + "|\n" +\
              "|" + 70*" " + "|\n" + \
              "+" + 70*"-" + "+\n"
    print header
    print "Reading parameter file..."
    # parse the config file
    params = parse_config()

    catalogs = get_catalogs(params["catalog_directory"], params["extension"])

    # start the output file
    output_file = start_output()

    print "Starting redshift fitting..."
    # Use sys.stdout.write instead of print so I can get an updating progress.
    sys.stdout.write("0/{} clusters finished.".format(len(catalogs)))
    sys.stdout.flush()

    for i, cat_path in enumerate(catalogs, start=1):
        cl = cluster.Cluster(cat_path, params)

        # do the fitting procedure
        cl.fit_z(params)

        # if the user wants to make rs catalogs, do it
        if params["rs_catalog_dir"] != '-99':
            cl.rs_catalog(params["rs_catalog_dir"] + cl.name + ".rs.cat")

        # make the output catalog
        add_to_catalog(output_file, cl)

        # update progress
        sys.stdout.write("\r")  # go back to the beginning of the line
        sys.stdout.write("{}/{} clusters finished.".format(i, len(catalogs)))
        sys.stdout.flush()



    output_file.close()

    print "\n"



if __name__ == "__main__":
    main()

# TODO: actual slopes of the red sequence
# TODO: What is the format of the catalogs I will get?
# TODO: correction
# TODO: make a readme that explains the science and workings behind the code
# TODO: make a .txt file documenting how to run the code.
# TODO: add liscense?

# TODO: make the name be just the filename stripped of the extension.
